# AI 时代编码策略和步骤.md 

## 1. 引言：AI 协同下的快速骨架构建与精化

在 AI 时代，编码不再是从零开始的逐行键入，而是人与 AI 协同，快速将设计蓝图转化为可运行系统的过程。本指南采用**“纵向切片”(Walking Skeleton)策略**，并将其执行明确划分为两个主要阶段，以平衡速度、集成验证和最终质量。

*   **阶段一 (Phase 1): MVP 功能骨架构建与端到端验证。** 目标是快速实现 MVP 范围内的所有核心功能流，并主要通过**端到端 (E2E) 测试（快乐路径）**验证其集成可行性。此阶段接受“够用就好”的代码和明确标记的 `TODO`。
*   **阶段二 (Phase 2): 代码精化、健壮性增强与全面测试。** 在骨架稳定后，回头处理 Phase 1 留下的 `TODO`，优化代码，处理边缘情况，增强错误处理，并补充更全面的测试（单元、集成、E2E 异常路径）。

我们相信，只要需求清晰，AI 在生成基础逻辑方面是可靠的，因此将测试重点放在集成和端到端流程上，可以最大化开发效率。

## 2. 核心原则

1.  **纵向切片驱动 (Vertical Slice Driven):** 以端到端用户场景为单位进行开发。
2.  **Phase 1: 速度与 E2E 快乐路径验证优先 (Speed & E2E Happy Path First):** 快速打通所有核心功能流，主要通过 E2E 测试验证集成。
3.  **Phase 2: 质量与健壮性提升 (Quality & Robustness Focus):** 在功能骨架完成后，系统性地提升代码质量、处理边缘情况和错误。
4.  **AI 大幅参与生成与辅助 (Leverage AI Heavily):** 在两个阶段都积极利用 AI 生成代码、提供建议、辅助测试和重构。
5.  **人类主导决策与验证 (Human Steers & Validates):** 开发者定义切片、审阅 AI 输出、设计测试策略、处理复杂问题并对最终质量负责。
6.  **清晰的 TODO 是阶段桥梁 (Actionable TODOs Bridge Phases):** 在 Phase 1 中使用明确的 `// TODO:` 或 `# TODO:` 标记（最好带有分类，如 `TODO:ErrorHandling`, `TODO:EdgeCase`, `TODO:Optimize`），作为 Phase 2 的工作输入。
7.  **接受 AI 的详细性，适时重构 (Embrace AI Verbosity, Refactor Appropriately):** Phase 1 接受 AI 的详细注释和显式逻辑；Phase 2 可根据需要进行重构以提高可读性和效率。

## 3. 阶段划分与活动

### 阶段一 (Phase 1): MVP 功能骨架构建与 E2E 验证

**目标:** 快速构建出覆盖 MVP 所有核心功能的、端到端可运行的“骨架”系统。

**活动 (按纵向切片迭代):**

1.  **定义切片范围:** (同前) 选择最小但有价值的端到端场景。
2.  **AI 生成骨架代码:** (同前) 利用 AI 根据 UML 生成项目/模块/类/函数骨架。
3.  **填充最小化“快乐路径”逻辑:**
    *   **开发者 + AI 辅助:** 只实现让当前切片核心流程成功跑通所需的最少代码。
    *   **忽略错误处理和边缘情况:** 假设所有输入有效，所有外部调用成功。
    *   **大量使用硬编码/Mock (如有必要):** 快速替代未实现的依赖。
    *   **留下清晰的 TODO:** `// TODO:ErrorHandling - Handle API request failure.` `# TODO:EdgeCase - What if user input is empty?`
4.  **本地集成与 E2E 快乐路径测试:**
    *   **开发者主导:** 手动或通过自动化脚本执行当前切片的**核心成功路径**。
    *   **测试重点:** 验证数据流是否通畅？前后端接口是否匹配？核心功能是否按预期完成（在理想条件下）？
    *   **自动化 E2E (可选但推荐):** 使用 Playwright, Cypress 等工具编写**只覆盖快乐路径**的 E2E 测试脚本。AI 可以辅助生成这些脚本的框架。
    *   **单元/集成测试 (最小化):** **除非某段逻辑极其关键、复杂且独立（与集成关系不大），否则 Phase 1 不强制要求单元/集成测试。** 如果需要，可让 AI 快速生成基础框架。
5.  **部署切片 (可选):** 部署到测试环境，进行早期演示或反馈。
6.  **Phase 1 切片收尾:**
    *   快速代码回顾，确保 E2E 快乐路径通过。
    *   **确保 TODO 清晰、可操作**，能指导 Phase 2 工作。
    *   **不进行大规模重构。**

**Phase 1 产出:**

*   一个功能上覆盖 MVP 范围，但比较“脆弱”（缺乏健壮性）的、端到端基本可运行的系统。
*   覆盖核心流程快乐路径的 E2E 测试（手动或自动）。
*   一份清晰的、分类的 TODO 列表（分布在代码中）。
*   所有后端 API 和数据模型已基本建立（支撑 MVP 功能）。

---

### 阶段二 (Phase 2): 代码精化、健壮性增强与全面测试

**目标:** 在 Phase 1 的骨架基础上，系统性地提升代码质量、处理各种边界情况和错误，确保系统稳定可靠。

**活动 (可按模块、按风险、按 TODO 类别进行):**

1.  **梳理和优先级排序 TODO:**
    *   **开发者主导:** 收集 Phase 1 留下的所有 TODO，根据风险、影响范围、业务重要性进行优先级排序。
2.  **处理 TODO - 增强健壮性:**
    *   **开发者 + AI 辅助:**
        *   **错误处理:** 实现 API 调用失败、数据库操作失败、无效用户输入等的处理逻辑（try-catch, 返回合适的错误码/信息）。AI 可以提供常见的错误处理模式。
        *   **边缘情况:** 处理空值、边界值、异常输入、并发问题（如果适用）等。AI 可以帮助思考可能的边缘情况。
        *   **安全性:** 检查和加固认证、授权、输入验证等方面（基于 Phase 1 的 TODO 或安全最佳实践）。
        *   **验证逻辑:** 实现更完善的数据校验规则。
3.  **代码优化与重构:**
    *   **开发者主导 + AI 辅助:**
        *   **消除重复:** 提取公共函数或组件。
        *   **提高可读性:** 改进命名、简化复杂逻辑。
        *   **性能优化 (如有必要):** 根据性能测试结果或明显瓶颈进行优化（如数据库查询优化、前端渲染优化）。
        *   AI 可以对选定代码块提出重构建议或应用某些设计模式。
4.  **补充全面的自动化测试:**
    *   **开发者 + AI 辅助:**
        *   **单元测试:** 为核心业务逻辑、复杂函数、工具函数编写单元测试。AI 可以生成测试用例框架和 Mock。
        *   **集成测试:** 测试模块之间、服务与数据库/外部 API 之间的交互。AI 可以生成测试设置和调用序列。
        *   **扩展 E2E 测试:** 增加覆盖**异常路径和边缘情况**的 E2E 测试场景。

**Phase 2 产出:**

*   一个功能完整、更健壮、经过优化的 MVP 版本。
*   一套更全面的自动化测试套件（单元、集成、扩展的 E2E）。
*   显著减少或消除了 Phase 1 的技术债。
*   为产品发布或下一轮迭代奠定了更坚实的基础。

## 4. 结论

这种两阶段编码策略，充分利用了 AI 在快速生成和辅助方面的优势，同时通过明确的阶段划分和测试重点调整，确保了开发速度与最终质量的平衡。Phase 1 快速构建并验证端到端的功能骨架，Phase 2 则在此基础上进行精雕细琢和加固。清晰的 `TODO` 标记是连接两个阶段的关键。这种方法特别适合独立开发者或小团队，能够在 AI 的帮助下，高效地将想法转化为可靠的产品。