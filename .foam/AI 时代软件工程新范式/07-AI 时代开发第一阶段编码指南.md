# AI 时代开发第一阶段编码指南.md
**(Phase 1: MVP 功能骨架构建与验证 - 注释优先版)**

## 0. 定义：“第一阶段 (Phase 1)” - MVP 功能骨架构建与验证

**“第一阶段 (Phase 1)”** 在本指南中特指 AI 协同开发流程中的一个核心编码阶段。其**唯一且明确的目标**是：

**以最快的速度，基于先前已验证的技术栈（来自 MVP 技术试验）和结构化设计（来自 AI UML 架构师），构建出覆盖 MVP (Minimum Viable Product) 范围内所有核心用户场景的“快乐路径”(Happy Path) 的、端到端（UI <-> API <-> DB）可运行的功能骨架。**

**关键特征与边界:**

*   **目标:** 快速实现功能骨架，验证端到端集成可行性。
*   **范围:** 仅覆盖 MVP 定义的核心功能流。
*   **代码质量:** 接受“刚好够用”的实现，**允许编码粗糙**，不追求性能优化、扩展性或代码优雅性。
*   **逻辑完整性:** 只需实现核心成功路径的逻辑，**明确忽略**复杂的错误处理、边缘情况覆盖和完善的输入验证。
*   **测试重点:** 主要通过**端到端 (E2E) 测试（手动或自动）验证核心成功路径**是否跑通。单元和集成测试在此阶段为次要或可选。
*   **核心产出:**
    1.  一个端到端基本可运行的 MVP 功能骨架。
    2.  **一套极其详尽、结构化的代码注释系统**，清晰定义接口契约、数据流、依赖关系，并包含大量明确的、指向 Phase 2 的 `TODO` 标记。**在此阶段，注释质量优先于代码质量，“代码 + 注释”共同构成核心文档。**
    3.  (可选) 覆盖快乐路径的 E2E 测试脚本。
*   **非目标:** 交付生产就绪 (Production-Ready) 的代码；实现高健壮性、高可用性或高性能；覆盖所有可能的错误或边缘情况。

**Phase 1 的成功标志是：** 能够快速、可靠地证明 MVP 核心功能流可以在选定的技术栈上端到端地运行起来（仅限快乐路径），并且所有已知的不完善之处都已被清晰地记录（通过高质量注释和 TODOs），为下一阶段 (Phase 2) 的精化工作铺平了道路。

---

## 1. 引言：执行 Phase 1 - AI 加速的骨架构建与文档化

本指南详细阐述如何在 AI 的协同下高效执行**第一阶段 (Phase 1)** 的编码工作。我们采用**“纵向切片”(Walking Skeleton)策略**，并严格遵循**“编码粗糙，注释明晰”**的核心原则。目标是快速将《AI UML 架构师规约包》定义的结构化蓝图，转化为一个端到端基本可运行的功能骨架。在此阶段，高质量的注释不仅是代码的补充，更是驱动后续 Phase 2 精化工作的核心“文档”和 AI 理解上下文的关键。

## 2. 核心原则 (Phase 1 执行层面)

1.  **速度与联通性优先 (Velocity & Connectivity First):** 首要目标是让选定的纵向切片尽快跑通，验证各层（UI, API, DB）之间的连接。
2.  **注释驱动理解 (Comment-Driven Understanding):** 投入时间和精力编写清晰、准确、详尽的注释，优先于打磨代码本身。注释是给未来的自己和 AI 队友看的。
3.  **快乐路径聚焦 (Happy Path Focus):** 严格限定在成功场景的实现，主动忽略或用 TODO 标记错误处理和边缘情况。
4.  **AI 生成为主，人工整合为辅 (AI Generates, Human Integrates):** 最大化利用 AI 生成代码骨架、基础逻辑和注释框架。开发者负责审阅、连接、调试集成点，并完善关键注释。
5.  **明确记录技术债 (Document Tech Debt Explicitly):** 使用结构化的 `TODO` 注释（如 `// TODO:Category - Description [optional link to requirement/spike]`) 来清晰标记所有已知的不完善之处。
6.  **小步快跑，尽早集成 (Small Steps, Integrate Early):** 每个切片内部也可以进一步细分为更小的步骤，每完成一小步（如 API 端点骨架 -> Service 调用 -> Repository 调用 -> DB 连接确认），就尝试本地运行和集成测试。

## 3. 输入与准备

*   **必需输入:**
    *   《AI UML 架构师规约包》 (包含分层文本 UML 和注释)
    *   《MVP 技术试验系列文档》 (包含 Spikes 结论和关键配置/代码)
*   **开发环境:** 确保本地环境就绪。
*   **AI 工具:** 配置好 AI 代码助手和可能的代码生成脚本/工具。
*   **代码仓库:** 初始化 Git 仓库，建立基础分支策略（如 `main`, `develop`）。

## 4. 核心编码步骤 (按纵向切片迭代)

### 步骤 4.1: 定义切片与识别接口契约

*   **开发者主导:**
    *   选择本轮迭代的纵向切片。
    *   **查阅 UML 规约:** 重点看该切片涉及的 L2 组件图（依赖关系）和 L3 类图（数据结构 DTOs/Entities, 接口签名）、序列图（交互流程）。
    *   **明确接口契约:** 在开始编码前，再次确认切片涉及的关键接口（API 端点、服务方法、仓库方法）的**输入参数、返回值和基本行为**（基于 UML 和注释）。

### 步骤 4.2: AI 生成骨架代码与注释框架

*   **开发者指令 + AI 执行:**
    *   **指令 AI:** "根据 `xyz.puml` 中的类图/接口定义，为 [组件/模块/层] 生成 [语言/框架] 的代码骨架，并包含 [JSDoc/Docstring/...] 注释模板。"
    *   **批量生成:** 可以尝试一次性生成切片涉及的多个文件骨架（如 Controller, Service, Repository, Store, View）。
    *   **包含 DTOs/Entities:** 特别注意让 AI 生成精确的 DTO 和 Entity 类/类型定义（基于 UML 类图）。
    *   **包含基础配置 (可选):** AI 可以生成基础的路由注册、依赖注入配置、ORM 初始化代码框架（基于 Spikes 经验）。

### 步骤 4.3: 人工整合、连接与填充最小逻辑 + 【核心】编写详尽注释

*   **开发者主导 + AI 辅助:**
    *   **审阅与整合:** 检查 AI 生成的骨架文件，确保文件结构、命名、签名与 UML 和预期一致。将这些文件放入正确的项目目录结构中。
    *   **连接依赖:** 手动（或 AI 辅助）编写代码，将不同层/模块连接起来（例如，在 Controller 中注入 Service，在 Service 中注入 Repository）。
    *   **填充快乐路径逻辑:** 编写最少的代码让数据流能够跑通。
        *   **API 层:** 解析请求，调用 Service，直接返回 Service 结果（或进行最简单的 DTO 映射）。
        *   **Service 层:** 调用 Repository，执行最核心的业务判断（Phase 1 可能没有），映射数据。
        *   **Repository 层:** 调用 ORM 执行最简单的数据库操作（基于 Spike 验证过的代码）。
        *   **前端:** 处理用户输入，调用 Store Action，Action 调用 API Service，根据返回更新 State（最简方式），View 绑定 State 显示数据（最简方式）。
    *   **【注释！注释！注释！】:** **这是 Phase 1 最关键的手动工作！**
        *   **完善 AI 生成的注释框架:** 填充 `@summary`, `@param`, `@returns` 等，确保描述清晰、准确。
        *   **添加接口契约注释:** 在 API 端点、服务方法等关键接口处，再次明确契约。
        *   **解释数据流和依赖:** 在调用其他模块/服务的地方，简要说明目的和预期。
        *   **记录所有 TODO:** 使用结构化的 `TODO` 注释标记所有不完善之处。
            *   `// TODO:Validation(P1) - Add input validation for CreateRecipeDto fields.`
            *   `// TODO:ErrorHandling(P0) - Implement proper error handling for database connection failure.`
            *   `// TODO:Refactor(P2) - This mapping logic is duplicated, extract to a helper.`
            *   `// TODO:Feature(Phase2) - Implement 'isPublic' flag logic.`
            *   (P0/P1/P2 等可以表示 Phase 2 中的优先级)
        *   **引用来源:** `// Logic based on sequence_create_recipe.puml.` `// DB interaction pattern from spike-prisma-crud.md.`
    *   **AI 辅助:**
        *   用 AI 快速生成重复的 DTO 映射代码（然后审阅）。
        *   用 AI 解释你不确定的库函数用法。
        *   让 AI "为这段代码添加注释"，然后你来精炼和补充关键信息（特别是 TODO 和契约）。

### 步骤 4.4: 本地集成与 E2E 快乐路径测试

*   **开发者主导:**
    *   频繁地在本地运行整个切片涉及的部分（前端+后端+DB）。
    *   **核心目标:** 验证端到端**连接**是否通畅，基本数据流是否按预期传递（基于注释定义的契约）。
    *   **调试:** 主要解决连接错误、配置错误、基本的数据格式/类型不匹配、简单的逻辑错误。**不要陷入优化或处理边缘情况的泥潭。**
    *   **(推荐) 自动化 E2E 快乐路径:** 编写或 AI 生成仅验证成功场景的 E2E 脚本。

### 步骤 4.5: (可选但推荐) 部署切片

*   (同前) 将基本可运行的骨架部署到测试环境，验证部署流程，提供早期预览。

### 步骤 4.6: Phase 1 切片收尾 - 注释审查与知识沉淀

*   **开发者主导:**
    *   **代码回顾核心:** **再次审查注释的质量！**
        *   注释是否足以让几个月后的自己或一个新加入的 AI（或人）理解这段（可能粗糙的）代码的意图、接口和局限性？
        *   TODO 是否清晰、可操作、覆盖全面？
        *   接口契约是否在注释中明确？
    *   **确认快乐路径 E2E 通过。**
    *   **提交代码:** 将包含详尽注释和 TODO 的代码提交到版本控制系统。

## 5. Phase 1 核心产出

*   一个**功能骨架系统**，端到端基本可运行（仅限 MVP 快乐路径）。
*   一套**极其详尽、结构化、分布在代码中的注释系统**，作为 Phase 2 的主要输入和“活文档”。
*   (可选) 覆盖快乐路径的 E2E 自动化测试脚本。
*   一份明确的 **Phase 2 工作清单 (通过 TODO 体现)**。

## 6. 结论

AI 时代的第一阶段编码，是一场追求**速度、连接和清晰度（通过注释）**的行动。我们拥抱 AI 带来的效率，接受初版代码的不完美，但坚持通过高质量的注释来管理复杂性、明确接口、记录技术债。这种“编码粗糙，注释明晰”的策略，使得 Phase 1 的产出不仅是一个能跑通的骨架，更是一份嵌入代码中的、指导未来方向的、人机均可理解的“动态蓝图”。完成 Phase 1，意味着你为后续的精化、健壮化和全面测试（Phase 2）打下了最快、最清晰的基础。