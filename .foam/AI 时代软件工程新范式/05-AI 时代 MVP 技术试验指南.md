# AI 时代 MVP 技术试验指南.md
**(验证技术可行性，拥抱最新稳定版)**

## 1. 引言：在编码前拆除技术风险的“排雷”行动

在 AI 驱动的开发流程中，“MVP 技术试验”阶段是连接“计划做什么”（MVP 蓝图）和“实际怎么做”（编码实现）之间至关重要的“风险评估与验证”环节。虽然 AI 能够快速生成大量基础代码，但其知识库往往滞后于日新月异的技术发展（新版本、新特性、依赖变更、潜在 Bug）。

因此，本阶段的核心目标**不是实现任何用户可见的功能**，而是：

**主动识别并验证《MVP 蓝图设计文档》中提出的高层技术设想（尤其是那些新的、不确定的、或对 MVP 成功至关重要的技术选型和集成点），通过一系列高度聚焦、代码量极小的技术试验 (Spikes)，快速确认技术可行性，拥抱并熟悉最新稳定版本，积累实践经验。**

**核心产出不是功能代码，而是“可行性报告”——即一系列独立的 Spike 文档，记录了试验过程、结论、关键代码示例和遇到的坑。这些文档是为后续编码阶段（无论是人还是 AI 执行）提供的、基于实践的、规避风险的关键决策依据。**

本指南旨在提供执行这一关键“排雷”行动的最佳实践。

## 2. 核心原则

1.  **风险驱动 (Risk-Driven):** 优先试验那些对项目成功影响最大、不确定性最高、或你最不熟悉的技术点。
2.  **试验而非实现 (Experiment, Don't Implement):** Spike 的目标是回答一个具体的技术问题（“这个库能连上吗？”“这个新特性好用吗？”“这两个库能一起工作吗？”），而不是构建功能。
3.  **拥抱最新稳定版 (Embrace Latest Stable):** **默认使用当前最新的稳定版本**进行试验，除非有明确理由不这样做。这是了解和掌握新技术的最佳时机。接受并记录版本带来的变化。
4.  **超细粒度，快速失败 (Hyper-Granular, Fail Fast):** 将大的技术疑虑分解为极小的、几小时内就能得出结论的 Spikes。如果一个 Spike 快速失败且无简单解决方案，**果断记录并寻找替代方案**，避免沉没成本。
5.  **代码极简，能跑通试验即可 (Minimal Code, Just Enough to Run):** 只写验证当前 Spike 目标所必需的最少代码。大量使用 Mock、硬编码，忽略非核心逻辑和错误处理。
6.  **AI 为助手，非权威 (AI as Assistant, Not Authority):** 利用 AI 快速生成试验框架、查询基础用法，但**绝不依赖 AI 关于最新版本行为或复杂集成问题的判断**。**官方文档、社区和实际运行结果是最终的“事实来源”。**
7.  **文档是核心产出 (Documentation is the Key Output):** 每个 Spike 必须产出简明扼要的文档，记录目标、方法、结论、关键代码和遇到的问题（**特别是与 AI 知识或旧版本行为的差异**）。

## 3. 输入

*   **主要输入:** 《MVP 蓝图设计文档.md》 (特别是“高层技术考虑/设想”部分)。
*   **辅助输入:** 开发者的技术背景、对新技术的兴趣、社区中关于某些技术的讨论或警告。

## 4. 核心步骤 (迭代循环)

1.  **识别试验点 (Identify Experiment Points - Spike Candidates):**
    *   **开发者主导:**
        *   仔细阅读 MVP 蓝图中的“高层技术考虑/设想”列表。
        *   结合自身经验，判断哪些技术是**新的、不熟悉的、有潜在兼容性风险的、或者是 MVP 核心流程强依赖的关键集成点**。
        *   **主动质疑 AI 可能的知识盲区:** “我想用 X 库的最新 Y 特性，AI 可能不知道，需要验证。” “蓝图建议用 A 和 B 集成，社区最近有讨论说它们最新版有冲突，需要验证。”
        *   列出一个初步的 Spike 候选清单。

2.  **设计超细粒度 Spike (Design Hyper-Granular Spikes):**
    *   **开发者主导 + AI 辅助:**
        *   将每个候选试验点分解为**最小的可验证单元**。
        *   为每个单元定义一个 Spike，明确其：
            *   **唯一、具体的问题/目标:** (例如：“验证能否用 Prisma Client v5.x 连接到本地 PostgreSQL v16 并执行 `findFirst` 查询？”)
            *   **所需的最少技术/库/版本:**
            *   **预期的成功标准:** (例如：“控制台成功打印出查询结果，无报错。”)
        *   **AI 辅助:** 可以让 AI 根据目标建议可能的验证步骤或所需的最小代码结构。

3.  **AI 辅助快速搭建试验环境:**
    *   **开发者指令 + AI 执行:**
        *   针对当前 Spike，指令 AI 生成最小化的项目（可能是临时目录）、必要的配置文件（`package.json`, `tsconfig.json`, `docker-compose.yml` 基础版）、依赖安装命令。
        *   **强调版本:** 明确指示 AI 使用**最新稳定版本**的库（如果 AI 不知道，手动指定）。

4.  **编写并执行极简验证代码:**
    *   **开发者主导 + AI 辅助:**
        *   参考 Spike 设计，编写刚好能验证目标的**最少代码**。
        *   **直接使用官方文档:** 对于新版本或新特性，**优先查阅官方文档**获取最准确的用法示例，而不是完全依赖 AI 生成的代码。
        *   **AI 辅助:** 可用于生成基础函数框架、类型定义、简单的调用示例，开发者再根据官方文档和试验目标进行修改。
        *   **聚焦连接与核心行为:** 只关心能不能跑通，核心特性是否如预期工作。
        *   运行代码，观察输出和错误。

5.  **快速判断与决策:**
    *   **开发者主导:**
        *   **成功:** 达到了预期标准。
        *   **失败:** 未达到预期标准。
        *   **快速分析:** 如果失败，是配置错误？用法错误（参考官方文档）？还是确实存在 Bug 或不兼容性？
        *   **决策:**
            *   成功 -> 记录结论，进行下一个 Spike。
            *   简单错误 -> 快速修复并重新验证。
            *   复杂问题/Bug/不兼容 -> **停止投入时间！** 记录问题，考虑替代技术或方案，设计新的 Spike 来验证替代方案。

6.  **即时、精简的 Spike 文档 (核心产出):**
    *   **开发者主导:** **每个 Spike 完成后，立即创建其独立文档 (`spike-*.md`)。**
    *   **核心内容 (精简版):**
        *   **目标 (Goal):** 验证的具体问题。
        *   **技术/版本 (Tech/Versions):** 使用的关键库和**确切版本号**。
        *   **关键代码/配置 (Key Snippet/Config):** 最能说明问题的几行。
        *   **结果与结论 (Outcome & Conclusion):** **最重要！** 成功/失败？为什么？学到了什么？**与旧版本或 AI 知识的主要差异点？** 对后续开发的影响？（例如：“成功，Prisma v5.x 可用，但连接字符串格式有变。” “失败，库 X 最新版在此场景下有 Bug，建议暂时使用稳定旧版 Y 或寻找替代库 Z。”）
        *   **遇到的坑/Workaround (Gotchas/Workarounds):**
    *   **格式:** 简单 Markdown 即可，存储在 `/docs/spikes`。

## 5. AI 在此阶段的角色

*   **试验点识别助手 (辅助):** 根据功能需求提示可能的技术风险。
*   **Spike 设计建议者 (辅助):** 建议验证步骤或代码框架。
*   **极速环境搭建器:** 生成最小化项目和配置。
*   **基础代码片段引擎:** 提供 API 基础用法示例（**需结合官方文档验证！**）。
*   **信息查询入口:** 快速查询安装命令、基础概念（**不依赖其对最新版本的判断！**）。
*   **错误信息初步解读器:** 提供常见错误的可能解释。

**AI 在此阶段 *绝不* 是：**

*   **最新技术知识的权威来源！**
*   **复杂集成问题或 Bug 的诊断专家！**
*   **技术选型的最终决策者！**

## 6. 产出：基于实践的技术可行性报告

*   **一系列独立的 Spike 文档:** **这是本阶段最重要的交付物**，记录了对关键技术点的验证结果、实践经验、遇到的问题（特别是与过时知识的差异）以及最终的技术可行性结论。
*   **一组分散的、极简的示例代码片段:** 仅用于支撑 Spike 文档中的结论，**不保证可直接用于生产**。
*   **一份更新的、基于实践的技术选型决策依据:** 知道哪些技术可靠，哪些需要规避或更换。
*   **为 AI UML 架构师和 Phase 1 编码阶段提供的、经过验证的技术基础信息。**

## 7. 结论

AI 时代的 MVP 技术试验，是将“快速失败、快速学习”精神应用于技术选型和集成的关键实践。通过拥抱最新稳定版、进行超细粒度的 Spike 验证、并以**详实的 Spike 文档作为核心产出**，我们可以有效地管理因 AI 知识滞后和技术快速迭代带来的风险。AI 在此阶段是强大的**效率助推器**，但**开发者基于官方文档和实际运行结果的判断**才是确保技术方向正确的定海神针。完成这一阶段，意味着你为后续的编码实现扫清了主要的技术障碍，并积累了宝贵的实践经验。